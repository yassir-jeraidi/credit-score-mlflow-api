name: CD - Deploy to AWS

on:
  # CD runs on push to main (after PR merge from dev)
  push:
    branches: [main]
  # CD runs on PRs targeting main (deploy for testing)
  pull_request:
    branches: [main]
  # Manual deployment with specific image tag (for rollback)
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (e.g., sha-abc1234 or v1.0.0)"
        required: true
        type: string
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ===========================================================================
  # Deploy to AWS EC2 via Docker Compose
  # Uses images already built by CI on dev branch
  # ===========================================================================
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual deployment - use provided tag
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "ðŸ”– Using manual tag: ${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # PR - use the PR head SHA (same as dev branch commit)
            SHORT_SHA=$(echo "${{ github.event.pull_request.head.sha }}" | cut -c1-7)
            echo "tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
            echo "ðŸ”– Using PR head SHA tag: sha-${SHORT_SHA}"
          else
            # Push to main - use current commit SHA
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
            echo "ðŸ”– Using SHA tag: sha-${SHORT_SHA}"
          fi

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify images exist in registry
        id: verify
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          echo "ðŸ” Verifying images exist in GHCR..."
          echo "   Looking for images built by CI on dev branch..."
          
          # Check API image
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-api > /dev/null 2>&1; then
            echo "âœ… API image found: ${TAG}-api"
          else
            echo "âŒ API image not found: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-api"
            echo ""
            echo "ðŸ’¡ This image should have been built by CI on the dev branch."
            echo "   Make sure CI completed successfully before merging to main."
            exit 1
          fi
          
          # Check UI image
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-ui > /dev/null 2>&1; then
            echo "âœ… UI image found: ${TAG}-ui"
          else
            echo "âŒ UI image not found: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-ui"
            echo ""
            echo "ðŸ’¡ This image should have been built by CI on the dev branch."
            echo "   Make sure CI completed successfully before merging to main."
            exit 1
          fi
          
          echo ""
          echo "âœ… All images verified! Ready to deploy."

      - name: Verify Docker on EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER || 'ubuntu' }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            set -e
            
            echo "ðŸ” Verifying Docker installation..."
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "âŒ Docker is not installed on this server!"
              echo ""
              echo "To install Docker, run:"
              echo "  curl -fsSL https://get.docker.com -o get-docker.sh"
              echo "  sudo sh get-docker.sh"
              echo "  sudo usermod -aG docker \$USER"
              exit 1
            fi
            
            # Prune to free space for swap file if needed
            echo "ðŸ§¹ Cleaning up disk space before verification..."
            docker system prune -af --volumes=false
            
            DOCKER_VERSION=$(docker --version)
            echo "âœ… Docker installed: $DOCKER_VERSION"
            
            # Check if Docker Compose is available
            if docker compose version &> /dev/null; then
              COMPOSE_VERSION=$(docker compose version --short)
              echo "âœ… Docker Compose (plugin) installed: $COMPOSE_VERSION"
            elif command -v docker-compose &> /dev/null; then
              COMPOSE_VERSION=$(docker-compose --version)
              echo "âœ… Docker Compose (standalone) installed: $COMPOSE_VERSION"
            else
              echo "âŒ Docker Compose is not installed!"
              exit 1
            fi
            
            # Check if Docker daemon is running
            if ! docker info &> /dev/null; then
              echo "âŒ Docker daemon is not running!"
              exit 1
            fi
            echo "âœ… Docker daemon is running"
            
            # Check and create Swap (crucial for t2.micro)
            if [ $(swapon --show | wc -l) -eq 0 ]; then
              echo "âš ï¸ No swap detected. Creating 2GB swap file..."
              sudo fallocate -l 2G /swapfile || sudo dd if=/dev/zero of=/swapfile bs=1M count=2048
              sudo chmod 600 /swapfile
              sudo mkswap /swapfile
              sudo swapon /swapfile
              echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
              echo "âœ… Swap created and enabled!"
            else
              echo "âœ… Swap already exists."
            fi
            
            echo ""
            echo "ðŸŽ‰ All Docker prerequisites verified!"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.2.0
        env:
          IMAGE_TAG: ${{ steps.tag.outputs.tag }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER || 'ubuntu' }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          envs: IMAGE_TAG
          timeout: 30m
          command_timeout: 30m
          script: |
            set -e
            
            echo "ðŸ§¹ Cleaning up disk space..."
            # Aggressively clean up unused images, containers, and networks to free space
            docker system prune -af --volumes=false
            
            echo "ðŸš€ Starting deployment with tag: ${IMAGE_TAG}"
            echo "   (Images were built by CI on dev branch)"

            # Source environment variables for docker compose interpolation
            # This makes GOOGLE_GENERATIVE_AI_API_KEY and SESSION_SECRET available
            set -a
            source /home/ubuntu/.env.credit-score
            set +a
            
            # Login to GHCR
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Create Prometheus config
            cat > prometheus.yml <<EOF
            global:
              scrape_interval: 15s
              evaluation_interval: 15s
              external_labels:
                monitor: 'credit-score-monitor'
            
            scrape_configs:
              - job_name: 'prometheus'
                static_configs:
                  - targets: ['localhost:9090']
              
              - job_name: 'credit-score-api'
                static_configs:
                  - targets: ['api:8000']
                metrics_path: '/metrics'
                scrape_interval: 10s
                scrape_timeout: 5s
            EOF
            
            # Create deployment compose file
            cat > docker-compose.deploy.yml <<EOF
            services:
              # =================================================================
              # PostgreSQL Database (MLflow Backend Store)
              # =================================================================
              postgres:
                image: postgres:15-alpine
                restart: always
                container_name: credit-score-postgres
                env_file:
                  - /home/ubuntu/.env.credit-score
                volumes:
                  - postgres_data:/var/lib/postgresql/data
                healthcheck:
                  test: ["CMD-SHELL", "pg_isready -U \${POSTGRES_USER} -d \${POSTGRES_DB}"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
                networks:
                  - credit-score-network

              # =================================================================
              # MLflow Tracking Server
              # =================================================================
              mlflow:
                image: ghcr.io/${{ github.repository }}:${IMAGE_TAG}-mlflow
                restart: always
                container_name: credit-score-mlflow
                depends_on:
                  postgres:
                    condition: service_healthy
                environment:
                  MLFLOW_BACKEND_STORE_URI: postgresql://\${POSTGRES_USER}:\${POSTGRES_PASSWORD}@postgres:5432/\${POSTGRES_DB}
                  MLFLOW_ARTIFACT_ROOT: /mlflow/artifacts
                volumes:
                  - mlflow_artifacts:/mlflow/artifacts
                command: >
                  mlflow server --backend-store-uri postgresql://\${POSTGRES_USER}:\${POSTGRES_PASSWORD}@postgres:5432/\${POSTGRES_DB} 
                  --default-artifact-root /mlflow/artifacts 
                  --host 0.0.0.0 --port 5001
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:5001/api/2.0/mlflow/experiments/search?max_results=1"]
                  interval: 30s
                  timeout: 10s
                  retries: 10
                  start_period: 30s
                networks:
                  - credit-score-network

              # =================================================================
              # Credit Score API
              # =================================================================
              api:
                image: ghcr.io/${{ github.repository }}:${IMAGE_TAG}-api
                container_name: credit-score-api
                env_file:
                  - /home/ubuntu/.env.credit-score
                environment:
                  - POSTGRES_HOST=postgres
                  - MLFLOW_TRACKING_URI=http://mlflow:5001
                ports:
                  - "8000:8000"
                restart: unless-stopped
                depends_on:
                  postgres:
                    condition: service_healthy
                  mlflow:
                    condition: service_healthy
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8000/api/v1/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
                networks:
                  - credit-score-network

              # =================================================================
              # Prometheus Monitoring
              # =================================================================
              prometheus:
                image: prom/prometheus:v2.48.0
                container_name: credit-score-prometheus
                volumes:
                  - ./prometheus.yml:/etc/prometheus/prometheus.yml:ro
                  - prometheus_data:/prometheus
                ports:
                  - "9090:9090"
                command:
                  - "--config.file=/etc/prometheus/prometheus.yml"
                  - "--storage.tsdb.path=/prometheus"
                  - "--web.enable-lifecycle"
                healthcheck:
                  test: ["CMD", "wget", "-q", "--spider", "http://localhost:9090/-/healthy"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                networks:
                  - credit-score-network

              # =================================================================
              # Next.js UI
              # =================================================================
              ui:
                image: ghcr.io/${{ github.repository }}:${IMAGE_TAG}-ui
                container_name: credit-score-ui
                environment:
                  API_BASE_URL: http://api:8000
                  NEXT_PUBLIC_API_URL: http://api:8000
                  GOOGLE_GENERATIVE_AI_API_KEY: \${GOOGLE_GENERATIVE_AI_API_KEY}
                  SESSION_SECRET: \${SESSION_SECRET}
                depends_on:
                  - api
                ports:
                  - "3000:3000"
                restart: unless-stopped
                networks:
                  - credit-score-network

            volumes:
              postgres_data:
              mlflow_artifacts:
              prometheus_data:

            networks:
              credit-score-network:
                driver: bridge
            EOF
            
            # Pull images (already built by CI)
            echo "ðŸ“¦ Pulling images from GHCR..."
            docker compose -f docker-compose.deploy.yml pull
            
            # Deploy
            echo "ðŸ”„ Deploying containers..."
            docker compose -f docker-compose.deploy.yml up -d --remove-orphans
            
            # Clean up old images
            docker image prune -f
            
            echo "âœ… Deployment completed!"
            echo "ðŸ“ Deployed tag: ${IMAGE_TAG}"

      - name: Health check
        uses: appleboy/ssh-action@v1.2.0
        if: ${{ github.event.inputs.skip_health_check != 'true' }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER || 'ubuntu' }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            echo "â³ Waiting for services to start..."
            sleep 30
            
            echo "ðŸ” Running health checks..."
            
            FAILED=false
            
            # Check API health
            API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health || echo "000")
            if [ "$API_STATUS" == "200" ]; then
              echo "âœ… API is healthy (HTTP $API_STATUS)"
            else
              echo "âš ï¸ API health check returned HTTP $API_STATUS"
              FAILED=true
            fi
            
            # Check UI health
            UI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 || echo "000")
            if [ "$UI_STATUS" == "200" ]; then
              echo "âœ… UI is healthy (HTTP $UI_STATUS)"
            else
              echo "âš ï¸ UI health check returned HTTP $UI_STATUS"
              FAILED=true
            fi
            
            if [ "$FAILED" == "true" ]; then
              echo ""
              echo "âŒ Health checks failed! Fetching container logs..."
              echo "==================================================="
              echo ">>> API Logs (last 50 lines):"
              docker compose -f docker-compose.deploy.yml logs --tail=50 api
              echo ""
              echo ">>> UI Logs (last 50 lines):"
              docker compose -f docker-compose.deploy.yml logs --tail=50 ui
              echo "==================================================="
              exit 1
            fi

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | \`${{ steps.tag.outputs.tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **API Image** | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.tag }}-api\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **UI Image** | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.tag }}-ui\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployed At** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |" >> $GITHUB_STEP_SUMMARY
          echo "| **Built By** | CI workflow on dev branch |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Access" >> $GITHUB_STEP_SUMMARY
          echo "- API: http://${{ secrets.DEPLOY_HOST }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "- UI: http://${{ secrets.DEPLOY_HOST }}:3000" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Create Release (on tag push)
  # ===========================================================================
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get tag name
        id: tag
        run: |
          TAG_NAME="${{ github.ref_name }}"
          echo "name=${TAG_NAME}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        uses: orhun/git-cliff-action@v3
        with:
          config: .github/cliff.toml
          args: --latest --strip header
        continue-on-error: true

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.name }}
          body: |
            ## Docker Images

            **API Image:**
            ```
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.name }}-api
            ```

            **UI Image:**
            ```
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.name }}-ui
            ```

            ## Changelog
            ${{ steps.changelog.outputs.content }}
          draft: false
          prerelease: ${{ contains(steps.tag.outputs.name, 'alpha') || contains(steps.tag.outputs.name, 'beta') || contains(steps.tag.outputs.name, 'rc') }}
