name: CD - Deploy to AWS

on:
  # CD runs on push to main (after PR merge from dev)
  push:
    branches: [main]
  # CD runs on PRs targeting main (deploy for testing)
  pull_request:
    branches: [main]
  # Manual deployment with specific image tag (for rollback)
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (e.g., sha-abc1234 or v1.0.0)"
        required: true
        type: string
      skip_health_check:
        description: "Skip health check after deployment"
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # ===========================================================================
  # Deploy to AWS EC2 via Docker Compose
  # Uses images already built by CI on dev branch
  # ===========================================================================
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine image tag
        id: tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Manual deployment - use provided tag
            echo "tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "ðŸ”– Using manual tag: ${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.event_name }}" == "pull_request" ]; then
            # PR - use the PR head SHA (same as dev branch commit)
            SHORT_SHA=$(echo "${{ github.event.pull_request.head.sha }}" | cut -c1-7)
            echo "tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
            echo "ðŸ”– Using PR head SHA tag: sha-${SHORT_SHA}"
          else
            # Push to main - use current commit SHA
            SHORT_SHA=$(echo "${{ github.sha }}" | cut -c1-7)
            echo "tag=sha-${SHORT_SHA}" >> $GITHUB_OUTPUT
            echo "ðŸ”– Using SHA tag: sha-${SHORT_SHA}"
          fi

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Verify images exist in registry
        id: verify
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          echo "ðŸ” Verifying images exist in GHCR..."
          echo "   Looking for images built by CI on dev branch..."
          
          # Check API image
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-api > /dev/null 2>&1; then
            echo "âœ… API image found: ${TAG}-api"
          else
            echo "âŒ API image not found: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-api"
            echo ""
            echo "ðŸ’¡ This image should have been built by CI on the dev branch."
            echo "   Make sure CI completed successfully before merging to main."
            exit 1
          fi
          
          # Check UI image
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-ui > /dev/null 2>&1; then
            echo "âœ… UI image found: ${TAG}-ui"
          else
            echo "âŒ UI image not found: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${TAG}-ui"
            echo ""
            echo "ðŸ’¡ This image should have been built by CI on the dev branch."
            echo "   Make sure CI completed successfully before merging to main."
            exit 1
          fi
          
          echo ""
          echo "âœ… All images verified! Ready to deploy."

      - name: Verify Docker on EC2
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER || 'ubuntu' }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          script: |
            set -e
            
            echo "ðŸ” Verifying Docker installation..."
            
            # Check if Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "âŒ Docker is not installed on this server!"
              echo ""
              echo "To install Docker, run:"
              echo "  curl -fsSL https://get.docker.com -o get-docker.sh"
              echo "  sudo sh get-docker.sh"
              echo "  sudo usermod -aG docker \$USER"
              exit 1
            fi
            
            DOCKER_VERSION=$(docker --version)
            echo "âœ… Docker installed: $DOCKER_VERSION"
            
            # Check if Docker Compose is available
            if docker compose version &> /dev/null; then
              COMPOSE_VERSION=$(docker compose version --short)
              echo "âœ… Docker Compose (plugin) installed: $COMPOSE_VERSION"
            elif command -v docker-compose &> /dev/null; then
              COMPOSE_VERSION=$(docker-compose --version)
              echo "âœ… Docker Compose (standalone) installed: $COMPOSE_VERSION"
            else
              echo "âŒ Docker Compose is not installed!"
              exit 1
            fi
            
            # Check if Docker daemon is running
            if ! docker info &> /dev/null; then
              echo "âŒ Docker daemon is not running!"
              exit 1
            fi
            echo "âœ… Docker daemon is running"
            
            echo ""
            echo "ðŸŽ‰ All Docker prerequisites verified!"

      - name: Deploy to EC2
        uses: appleboy/ssh-action@v1.2.0
        env:
          IMAGE_TAG: ${{ steps.tag.outputs.tag }}
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER || 'ubuntu' }}
          key: ${{ secrets.DEPLOY_SSH_KEY }}
          envs: IMAGE_TAG
          script: |
            set -e
            
            echo "ðŸš€ Starting deployment with tag: ${IMAGE_TAG}"
            echo "   (Images were built by CI on dev branch)"
            
            # Login to GHCR
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Create deployment compose file
            cat > docker-compose.deploy.yml <<EOF
            version: "3.9"
            services:
              api:
                image: ghcr.io/${{ github.repository }}:${IMAGE_TAG}-api
                env_file:
                  - /home/ubuntu/.env.credit-score
                ports:
                  - "8000:8000"
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s

              ui:
                image: ghcr.io/${{ github.repository }}:${IMAGE_TAG}-ui
                environment:
                  API_BASE_URL: http://api:8000
                  NEXT_PUBLIC_API_URL: http://api:8000
                  GOOGLE_GENERATIVE_AI_API_KEY: \${GOOGLE_GENERATIVE_AI_API_KEY}
                  SESSION_SECRET: \${SESSION_SECRET}
                depends_on:
                  - api
                ports:
                  - "3000:3000"
                restart: unless-stopped

            networks:
              default:
                name: credit-score-network
            EOF
            
            # Pull images (already built by CI)
            echo "ðŸ“¦ Pulling images from GHCR..."
            docker compose -f docker-compose.deploy.yml pull
            
            # Deploy
            echo "ðŸ”„ Deploying containers..."
            docker compose -f docker-compose.deploy.yml up -d --remove-orphans
            
            # Clean up old images
            docker image prune -f
            
            echo "âœ… Deployment completed!"
            echo "ðŸ“ Deployed tag: ${IMAGE_TAG}"

      - name: Health check
        if: ${{ github.event.inputs.skip_health_check != 'true' }}
        run: |
          echo "â³ Waiting for services to start..."
          sleep 30
          
          echo "ðŸ” Running health checks..."
          
          FAILED=false
          
          # Check API health
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.DEPLOY_HOST }}:8000/health || echo "000")
          if [ "$API_STATUS" == "200" ]; then
            echo "âœ… API is healthy (HTTP $API_STATUS)"
          else
            echo "âš ï¸ API health check returned HTTP $API_STATUS"
            FAILED=true
          fi
          
          # Check UI health
          UI_STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://${{ secrets.DEPLOY_HOST }}:3000 || echo "000")
          if [ "$UI_STATUS" == "200" ]; then
            echo "âœ… UI is healthy (HTTP $UI_STATUS)"
          else
            echo "âš ï¸ UI health check returned HTTP $UI_STATUS"
            FAILED=true
          fi
          
          if [ "$FAILED" == "true" ]; then
            echo ""
            echo "âŒ Health checks failed! Fetching container logs..."
            echo "==================================================="
            echo ">>> API Logs (last 50 lines):"
            docker compose -f docker-compose.deploy.yml logs --tail=50 api
            echo ""
            echo ">>> UI Logs (last 50 lines):"
            docker compose -f docker-compose.deploy.yml logs --tail=50 ui
            echo "==================================================="
            exit 1
          fi

      - name: Deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Image Tag** | \`${{ steps.tag.outputs.tag }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **API Image** | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.tag }}-api\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **UI Image** | \`${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.tag }}-ui\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Deployed At** | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |" >> $GITHUB_STEP_SUMMARY
          echo "| **Built By** | CI workflow on dev branch |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ðŸ”— Access" >> $GITHUB_STEP_SUMMARY
          echo "- API: http://${{ secrets.DEPLOY_HOST }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "- UI: http://${{ secrets.DEPLOY_HOST }}:3000" >> $GITHUB_STEP_SUMMARY

  # ===========================================================================
  # Create Release (on tag push)
  # ===========================================================================
  release:
    name: Create Release
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get tag name
        id: tag
        run: |
          TAG_NAME="${{ github.ref_name }}"
          echo "name=${TAG_NAME}" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        uses: orhun/git-cliff-action@v3
        with:
          config: .github/cliff.toml
          args: --latest --strip header
        continue-on-error: true

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.tag.outputs.name }}
          body: |
            ## Docker Images

            **API Image:**
            ```
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.name }}-api
            ```

            **UI Image:**
            ```
            docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.tag.outputs.name }}-ui
            ```

            ## Changelog
            ${{ steps.changelog.outputs.content }}
          draft: false
          prerelease: ${{ contains(steps.tag.outputs.name, 'alpha') || contains(steps.tag.outputs.name, 'beta') || contains(steps.tag.outputs.name, 'rc') }}
